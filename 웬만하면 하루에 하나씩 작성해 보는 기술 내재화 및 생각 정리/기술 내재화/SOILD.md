# SOILD 원칙
![soild](https://github.com/user-attachments/assets/6bad6c9e-421e-4e59-a8f6-08aedebed4d1)
> 객체지향의 설계 과정
> - 요구사항을 찾고 세부화 한다.
> - 기능을 구현하는데 필요한 데이터를 객체에 추가한다.
> - 데이터를 이용하는 기능을 구현한다(캡슐화 필요)
> - 객체간 메소드 호출을 어떻게 주고 받을지 결정
> 
> **객체지향 설계 원칙**
> 
> SRP (Single Responsibility Principle)
> - 클래스는 단 한개의 책임만을 가져야 한다.
> - 클래스를 변경하는 이유는 하나여야 한다.
> - 지키지 않게 되면 책임의 변경에 따라 다른 코드에 영향을 미칠 수 있음
>   - 유지보수가 힘들게 된다.
> 
> OCP (Open-Closed Principle)
> - 확장에는 열려있고 변경에는 닫혀있어야 한다.
> - 기존코드를 변경하지 않고 기능을 추가하거나 수정할 수 있도록 설계해야 한다.
> - 이를 지키지 않는다면 **instance of** 와 같은 연산자를 사용하거나, 다운 캐스팅 발생
> - OCP 는 추상화(인터페이스) 와 상속(다형성) 등을 통해 구현 가능
>   자주 변하는 부분을 추상화를 하여 기능을 확장할 수 있도록 구하면 유연성을 높일 수 있다.
> 
> LSP(Liskov Substitution Principle)
> - 상위 타입 객체를 하위 타입 객체로 치환해도 기능이 정상적으로 작동해야 한다.
> - 상속 관계에서는 반드시 일반화(IS-A)가 성립해야 한다(일관성이 있는지)
> - 리스코프 치환 원칙을 지키지 않으면 개방 폐쇄 원칙을 위반하게 되는 것이다. 기능 확장을 위해 기존의 코드를 여러 번 수정해야 할 것이다. 
>   - 따라서 상속 관계를 잘 정의하여 LSP 원칙이 위배되지 않도록 설계해야 함.
> 
> ISP(Interface Segregation Principle)
> - 클라이언트는 자신이 사용하는 메소드에만 의존해야한다.
> - 자신이 사용하지 않는 인터페이스는 구현하지 않아야 한다.
>   - 통합적인 인터페이스 하나보다 잘 나뉘어진 인터페이스가 더 낫다.
> - 클라이언트가 필요로 하는 인터페이스를 분리함으로써 사용하지 않는 인터페이스가 변경되더라도 영향이 없다.
> 
> DIP(Dependency Inversion Principle)
> - 의존 관계를 맺을 때 변하기 쉬운것(구체화) 보다 변하기 어려운 것(추상화)에 의존해야 함.
> - 저수준 모듈이 변경되더라도 고수준 모듈은 변경이 되지 않는것이 이상적이다.
> - 개발자는 추상화에 의존해야지 구체화에 의존하면 안된다.
> 
> 
> - SRP와 ISP는 객체가 커지는것을 막아주고 클라이언트마다 필요한 인터페이스를 구현함으로써 기능의 변경이 다른곳 까지 미치는
>   영향이 최소화 되며 이는 기능의 추가 및 변경이 용이하도록 만들어 준다.
> - LSP와 DIP는 OCP를 서포트 하고 OCP는 자주변하는 부분을 추상화 하고 다형성을 이용해 기능의 확장은 용이하게 되고 변화는 보수적으로 만들어준다.
>   여기서 '변화되는 부분을 추상화'할 수 있도록 도와주는 원칙이 DIP 이고, 다형성 구현을 도와주는 원칙이 LSP 인 것이다.
> 

